
*** things in RLCSA used by GCSA ***



** meaty things **
encoder is something that has bits incrementally added to it
it is later converted to a vector

* These are all derived from BitVector.  BitVector has a /buffer/ attribute which stores all the data.  It also has superblock and sample bookkeeping datastructures which are presumably used by the rank/select operations for constant time lookups (regardless of the encoding of the full dataset).  The original purpose of the common base class seems to be that they all share a common superblock/sample datastructure and routines -- not because they all have a similar interface (although they actually do).  Composition instead of inheritance might have been more fitting from a software engineering perspective. 

CSA::DeltaEncoder
CSA::DeltaVector
CSA::SuccinctEncoder
CSA::SuccinctVector
CSA::RLEEncoder
CSA::RLEVector


CSA::RLCSA

* contain various methods to encode the raw data in various ways.  These are used to access the /buffer/ attribute of a bitvector.
CSA::ReadBuffer
CSA::WriteBuffer

CSA::Alphabet

** simple utilities **
CSA::readRows
CSA::fileSize
CSA::largeWrite
CSA::length
CSA::memoryUsage
CSA::parallelSort
CSA::sequentialSort
CSA::removeDuplicates
CSA::readTimer

** simple types **
CSA::uchar
CSA::usint
CSA::sint
CSA::MEGABYTE
CSA::CHARS
CSA::EMPTY_PAIR
CSA::MILLION
CSA::pair_type


*** where different vectors are used and the methods invoked on them***

GCSA::array deltaVector for each character that exists in alphabet
array_iter.rank(range.first, true)
array_iter.select(index - this->alphabet->cumulative(c)
array_iter.selectNext()
array_iters[i]->isSet(lines - 1)


GCSA::outgoing rlevector
->getNumberOfItems()
->writeTo(output)
->reportSize()
->getSize()
outgoing_iter.select(index)
outgoing_iter.selectNext()
outgoing_iter.rank(edge_range.first)


GCSA::sampled_positions delta
sample_iter.isSet(index)
sample_iter.rank(temp)
sampled_positions->getNumberOfItems()
sampled_positions->writeTo(output)
sampled_positions->reportSize()

* there is a backbone attribute of Graph and also a Backbone class!

GCSA::backbone succinct

backbone->writeTo(base_name)
backbone->reportSize(print)
backbone->getNumberOfItems()
bb_iter->isSet(first - this->nodes)

backbone::original succinct
iter.isSet(index)
original->writeTo(output)
original->reportSize()

backbone::nodes succinct
his->nodes[this->edges[successors.first].rank].value() != this->nodes[current].value() + 1)
iter.isSet(index);
this->nodes[i].label

backbone::edges rle


* build_index crash notes *
BitVector::Iterator::Iterator(const BitVector& par) :
  parent(par),
  buffer(par.array, par.block_size), // this ReadBuffer is contructed successfully
  samples(*(par.samples)) //this one seems to crash

// the following constructor is running when the process is killed
ReadBuffer::ReadBuffer(const ReadBuffer& original) :
  data(original.data),
  size(original.size),
  item_bits(original.item_bits),
  items(original.items),
  free_buffer(false) 


seems to be backbone related; when -b is on early commands but omitted for build_index, it seems to work in the debugger


* build_index big mmap calls *
mmap(NULL, 137438957568, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0027166000
mmap(NULL, 34359742464, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2027f75000
mmap(NULL, 34359742464, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2828077000
